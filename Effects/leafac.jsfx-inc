/*
Circular buffer -> Array converter
Change the implementation of graphs to use arrays

Line graphs
  Zoom horizontally & vertically
  Line or area
Multichannel RMS
Let the user change the window sizes on simple moving average
Show RMS over time
RBJ Filter: Include formula to convert between width types and use to keep sliders in sync so that width doesn’t change when you change type

Data structures
  Arrays
    Getter for size
  Circular buffer
  Delay line
  Circular counter
  Matrix
  Follower

Design system
  border-width
  opacity
  rotate
  scale
  brightness
  contrast
  saturate
  animations
    transition-duration
    transition-timing-function

Components
  Oscilloscope
  Frequency spectrum analyzer
  Colorpicker

Algorithms
  Wrap numbers in a range
  Sort
    Smallest
    Find the median
    Largest
  Search
  Bézier
  Noise generation of various colors
  Random distributions
    Uniform
    Gaussian
  dB ↔ amplitude conversation
  degrees ↔ radians
  DFT
  Slew Rate
  Phase
    Unwrap
    Reduce noise by checking small values & returning 0

Filters
  Biquad
    rbj__q_to_bandwidth
  SVF
  Windowed-sinc
  Butterworth
  …

Document
  Dimensions for the @gfx block can’t use functions
  You must call the initializers
  How to manage different font sizes/styles/decoration
  Why always arial (because of retina + operating system font support)
    Workaround (render every text in the interface as images)
  _rounded_rectangle_fill can’t be used with opacity < 1
*/

@init

// UNIT CONVERSIONS

function _.milliseconds_to_samples(milliseconds) (
  milliseconds * srate * 0.001;
);
function _.samples_to_milliseconds(samples) (
  samples / srate * 1000;
);

function _.amplitude_to_db(amplitude) (
  amplitude == 0
  ? _.db.minimum
  : 20 * log10(abs(amplitude));
);
function _.db_to_amplitude(db) (
  10^(db / 20);
);

function _.radians_to_degrees(radians) (
  radians / $pi * 180;
);
function _.degrees_to_radians(degrees) (
  degrees / 180 * $pi;
);

// IMAGINARY NUMBERS

function _.imaginary.magnitude(real, imaginary) (
  sqrt(sqr(real) + sqr(imaginary));
);
function _.imaginary.phase(real, imaginary) (
  atan2(imaginary, real);
);

function _.imaginary.rectangular_to_polar(reals, imaginaries, magnitudes, phases) local(N, k, ReX, ImX, MagX, PhaseX) (
  ReX = reals[_.array.struct.data];
  ImX = imaginaries[_.array.struct.data];
  MagX = magnitudes[_.array.struct.data];
  PhaseX = phases[_.array.struct.data];
  N = reals[_.circular_buffer.struct.signal][_.array.struct.size];
  k = -1; loop(N, k += 1;
    MagX[k] = _.imaginary.magnitude(ReX[k], ImX[k]);
    PhaseX[k] = _.imaginary.phase(ReX[k], ImX[k]);
  );
);

// HYPERBOLIC FUNCTIONS

// https://en.wikipedia.org/wiki/Hyperbolic_functions#Exponential_definitions
function _.sinh(x) (
  (exp(x) - exp(-x)) / 2;
);
function _.cosh(x) (
  (exp(x) + exp(-x)) / 2;
);
function _.tanh(x) local(e_2x) (
  e_2x = exp(2 * x);
  (e_2x - 1) / (e_2x + 1);
);
function _.coth(x) local(e_2x) (
  e_2x = exp(2 * x);
  (e_2x + 1) / (e_2x - 1);
);
function _.sech(x) (
  2 / (exp(x) + exp(-x));
);
function _.csch(x) (
  2 / (exp(x) - exp(-x));
);

// https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions#Definitions_in_terms_of_logarithms
function _.arsinh(x) (
  log(x + sqrt(sqr(x) + 1));
);
function _.arcosh(x) (
  log(x + sqrt(sqr(x) - 1));
);
function _.artanh(x) (
  log((1 + x) / (1 - x)) / 2;
);
function _.arcoth(x) (
  log((x + 1) / (x - 1)) / 2;
);
function _.arsech(x) (
  log((1 + sqrt(1 - sqr(x))) / x);
);
function _.arcsch(x) (
  log(1 / x + sqrt((1 / sqr(x)) + 1));
);

// DATA STRUCTURES

_.enumeration.index = 9990000;
function _.enumeration() (
  _.enumeration.index += 1;
);

_.memory.next_available_address = 0;
function _.memory.new(size) local(address) (
  address = _.memory.next_available_address;
  _.memory.next_available_address += size;
  memset(address, 0, size);
  address;
);

function _.box() (
  _.memory.new(1);
);

function _.struct.define() (
  _.box();
);
function _.struct.define.field(struct_definition) local(field) (
  field = struct_definition[];
  struct_definition[] += 1;
  field;
);
function _.struct.new(struct_definition) (
  _.memory.new(struct_definition[]);
);

// ARRAYS

function _.array.init() (
  _.array.struct = _.struct.define();
  _.array.struct.size = _.struct.define.field(_.array.struct);
  _.array.struct.data = _.struct.define.field(_.array.struct);
);
function _.array.new(size) local(array) (
  array = _.struct.new(_.array.struct);
  array[_.array.struct.size] = size;
  array[_.array.struct.data] = _.memory.new(size);
  array;
);

// CIRCULAR BUFFERS

function _.circular_buffer.init() (
  _.circular_buffer.struct = _.struct.define();
  _.circular_buffer.struct.index = _.struct.define.field(_.circular_buffer.struct);
  _.circular_buffer.struct.signal = _.struct.define.field(_.circular_buffer.struct);
);
function _.circular_buffer.new(size) local(circular_buffer) (
  circular_buffer = _.struct.new(_.circular_buffer.struct);
  circular_buffer[_.circular_buffer.struct.index] = 0;
  circular_buffer[_.circular_buffer.struct.signal] = _.array.new(size);
  circular_buffer;
);
function _.circular_buffer.push(circular_buffer, sample) local(index, signal, signal_size, signal_data) (
  index = circular_buffer[_.circular_buffer.struct.index];
  signal = circular_buffer[_.circular_buffer.struct.signal];
  signal_size = signal[_.array.struct.size];
  signal_data = signal[_.array.struct.data];
  index += 1;
  index == signal_size ? index -= signal_size;
  circular_buffer[_.circular_buffer.struct.index] = index;
  signal_data[index] = sample;
  sample;
);
function _.circular_buffer.get(circular_buffer, offset) local(index, signal, signal_size, signal_data) (
  index = circular_buffer[_.circular_buffer.struct.index];
  signal = circular_buffer[_.circular_buffer.struct.signal];
  signal_size = signal[_.array.struct.size];
  signal_data = signal[_.array.struct.data];
  index += offset;
  index < 0 ? index += signal_size;
  signal_data[index];
);

// SIMPLE MOVING AVERAGES

function _.moving_average.simple.init() (
  _.moving_average.simple.struct = _.struct.define();
  _.moving_average.simple.struct.sum = _.struct.define.field(_.moving_average.simple.struct);
  _.moving_average.simple.struct.window = _.struct.define.field(_.moving_average.simple.struct);
);
function _.moving_average.simple.new(window_size) local(moving_average) (
  moving_average = _.struct.new(_.moving_average.simple.struct);
  moving_average[_.moving_average.simple.struct.sum] = 0;
  moving_average[_.moving_average.simple.struct.window] = _.circular_buffer.new(window_size);
  moving_average;
);
function _.moving_average.simple.push(moving_average, sample) local(sum, window, window_size) (
  sum = moving_average[_.moving_average.simple.struct.sum];
  window = moving_average[_.moving_average.simple.struct.window];
  window_size = window[_.circular_buffer.struct.signal][_.array.struct.size];
  sum = sum - _.circular_buffer.get(window, -window_size + 1) + sample;
  moving_average[_.moving_average.simple.struct.sum] = sum;
  _.circular_buffer.push(window, sample);
  sample;
);
function _.moving_average.simple.get(moving_average) local(sum, window, window_size) (
  sum = moving_average[_.moving_average.simple.struct.sum];
  window = moving_average[_.moving_average.simple.struct.window];
  window_size = window[_.circular_buffer.struct.signal][_.array.struct.size];
  sum / window_size;
);

// RMS

function _.rms.new(window_size) (
  _.moving_average.simple.new(window_size);
);
function _.rms.push(rms, sample) (
  _.moving_average.simple.push(rms, sqr(sample));
  sample;
);
function _.rms.get(rms) (
  sqrt(_.moving_average.simple.get(rms));
);

// BIQUAD FILTERS (RBJ FILTERS)

// Probably the canonical version:
// https://www.musicdsp.org/en/latest/Filters/197-rbj-audio-eq-cookbook.html
// More copies of the canonical version (typeset versions may be misleading—I think that the plaintext versions are better):
// https://webaudio.github.io/Audio-EQ-Cookbook/audio-eq-cookbook.html
// https://www.w3.org/TR/audio-eq-cookbook/
// https://shepazu.github.io/Audio-EQ-Cookbook/audio-eq-cookbook.html
// Outdated version:
// https://github.com/libaudioverse/libaudioverse/blob/master/audio%20eq%20cookbook.txt
// https://music.columbia.edu/pipermail/music-dsp/2001-March/041752.html

function _.filter.biquad.init() (
  _.filter.biquad.struct = _.struct.define();
  _.filter.biquad.struct.type = _.struct.define.field(_.filter.biquad.struct);
  _.filter.biquad.struct.type.low_pass = _.enumeration();
  _.filter.biquad.struct.type.high_pass = _.enumeration();
  _.filter.biquad.struct.type.band_pass.constant_skirt = _.enumeration();
  _.filter.biquad.struct.type.band_pass.constant_peak = _.enumeration();
  _.filter.biquad.struct.type.notch = _.enumeration();
  _.filter.biquad.struct.type.all_pass = _.enumeration();
  _.filter.biquad.struct.type.peaking = _.enumeration();
  _.filter.biquad.struct.type.low_shelf = _.enumeration();
  _.filter.biquad.struct.type.high_shelf = _.enumeration();
  _.filter.biquad.struct.frequency = _.struct.define.field(_.filter.biquad.struct);
  _.filter.biquad.struct.gain = _.struct.define.field(_.filter.biquad.struct);
  _.filter.biquad.struct.width.type = _.struct.define.field(_.filter.biquad.struct);
  _.filter.biquad.struct.width.type.Q = _.enumeration();
  _.filter.biquad.struct.width.type.bandwidth = _.enumeration();
  _.filter.biquad.struct.width.type.S = _.enumeration();
  _.filter.biquad.struct.width.value = _.struct.define.field(_.filter.biquad.struct);
  _.filter.biquad.struct.b0_a0 = _.struct.define.field(_.filter.biquad.struct);
  _.filter.biquad.struct.b1_a0 = _.struct.define.field(_.filter.biquad.struct);
  _.filter.biquad.struct.b2_a0 = _.struct.define.field(_.filter.biquad.struct);
  _.filter.biquad.struct.a0 = _.struct.define.field(_.filter.biquad.struct);
  _.filter.biquad.struct.a1_a0 = _.struct.define.field(_.filter.biquad.struct);
  _.filter.biquad.struct.a2_a0 = _.struct.define.field(_.filter.biquad.struct);
  _.filter.biquad.struct.x_n = _.struct.define.field(_.filter.biquad.struct);
  _.filter.biquad.struct.x_n_1 = _.struct.define.field(_.filter.biquad.struct);
  _.filter.biquad.struct.x_n_2 = _.struct.define.field(_.filter.biquad.struct);
  _.filter.biquad.struct.y_n = _.struct.define.field(_.filter.biquad.struct);
  _.filter.biquad.struct.y_n_1 = _.struct.define.field(_.filter.biquad.struct);
  _.filter.biquad.struct.y_n_2 = _.struct.define.field(_.filter.biquad.struct);
);
function _.filter.biquad.new() local(filter) (
  filter = _.struct.new(_.filter.biquad.struct);
  filter[_.filter.biquad.struct.type] = _.undefined;
  filter[_.filter.biquad.struct.frequency] = _.undefined;
  filter[_.filter.biquad.struct.gain] = _.undefined;
  filter[_.filter.biquad.struct.width.type] = _.undefined;
  filter[_.filter.biquad.struct.width.value] = _.undefined;
  filter[_.filter.biquad.struct.b0_a0] = _.undefined;
  filter[_.filter.biquad.struct.b1_a0] = _.undefined;
  filter[_.filter.biquad.struct.b2_a0] = _.undefined;
  filter[_.filter.biquad.struct.a0] = _.undefined;
  filter[_.filter.biquad.struct.a1_a0] = _.undefined;
  filter[_.filter.biquad.struct.a2_a0] = _.undefined;
  filter[_.filter.biquad.struct.x_n] = 0;
  filter[_.filter.biquad.struct.x_n_1] = 0;
  filter[_.filter.biquad.struct.x_n_2] = 0;
  filter[_.filter.biquad.struct.y_n] = 0;
  filter[_.filter.biquad.struct.y_n_1] = 0;
  filter[_.filter.biquad.struct.y_n_2] = 0;
  filter;
);
function _.filter.biquad.configure(filter, type, frequency, gain, width.type, width.value)
         local(A, w0, cos_w0, sin_w0, alpha,
               b0, b1, b2, a0, a1, a2, b0_a0, b1_a0, b2_a0, a1_a0, a2_a0) (
  A = 10^(gain / 40);
  w0 = 2 * $pi * frequency / srate;
  cos_w0 = cos(w0);
  sin_w0 = sin(w0);
  alpha =
    width.type == _.filter.biquad.struct.width.type.Q
    ? sin_w0 / (2 * width.value)
    : width.type == _.filter.biquad.struct.width.type.bandwidth
    ? sin_w0 * _.sinh(log(2) / 2 * width.value * w0 / sin_w0)
    : width.type == _.filter.biquad.struct.width.type.S
    ? sin_w0 / 2 * sqrt((A + 1 / A) * (1 / width.value - 1) + 2);
  type == _.filter.biquad.struct.type.low_pass ? (
    b0 = (1 - cos_w0) / 2;
    b1 = 1 - cos_w0;
    b2 = (1 - cos_w0) / 2;
    a0 = 1 + alpha;
    a1 = -2 * cos_w0;
    a2 = 1 - alpha;
  )
  : type == _.filter.biquad.struct.type.high_pass ? (
    b0 = (1 + cos_w0) / 2;
    b1 = -(1 + cos_w0);
    b2 = (1 + cos_w0) / 2;
    a0 = 1 + alpha;
    a1 = -2 * cos_w0;
    a2 = 1 - alpha;
  )
  : type == _.filter.biquad.struct.type.band_pass.constant_skirt ? (
    b0 = sin_w0 / 2;
    b1 = 0;
    b2 = -sin_w0 / 2;
    a0 = 1 + alpha;
    a1 = -2 * cos_w0;
    a2 = 1 - alpha;
  )
  : type == _.filter.biquad.struct.type.band_pass.constant_peak ? (
    b0 = alpha;
    b1 = 0;
    b2 = -alpha;
    a0 = 1 + alpha;
    a1 = -2 * cos_w0;
    a2 = 1 - alpha;
  )
  : type == _.filter.biquad.struct.type.notch ? (
    b0 = 1;
    b1 = -2 * cos_w0;
    b2 = 1;
    a0 = 1 + alpha;
    a1 = -2 * cos_w0;
    a2 = 1 - alpha;
  )
  : type == _.filter.biquad.struct.type.all_pass ? (
    b0 = 1 - alpha;
    b1 = -2 * cos_w0;
    b2 = 1 + alpha;
    a0 = 1 + alpha;
    a1 = -2 * cos_w0;
    a2 = 1 - alpha;
  )
  : type == _.filter.biquad.struct.type.peaking ? (
    b0 = 1 + alpha * A;
    b1 = -2 * cos_w0;
    b2 = 1 - alpha * A;
    a0 = 1 + alpha / A;
    a1 = -2 * cos_w0;
    a2 = 1 - alpha / A;
  )
  : type == _.filter.biquad.struct.type.low_shelf ? (
    b0 =      A * ((A + 1) - (A - 1) * cos_w0 + 2 * sqrt(A) * alpha);
    b1 =  2 * A * ((A - 1) - (A + 1) * cos_w0                      );
    b2 =      A * ((A + 1) - (A - 1) * cos_w0 - 2 * sqrt(A) * alpha);
    a0 =           (A + 1) + (A - 1) * cos_w0 + 2 * sqrt(A) * alpha;
    a1 =     -2 * ((A - 1) + (A + 1) * cos_w0                      );
    a2 =           (A + 1) + (A - 1) * cos_w0 - 2 * sqrt(A) * alpha;
  )
  : type == _.filter.biquad.struct.type.high_shelf ? (
    b0 =      A * ((A + 1) + (A - 1) * cos_w0 + 2 * sqrt(A) * alpha );
    b1 = -2 * A * ((A - 1) + (A + 1) * cos_w0                       );
    b2 =      A * ((A + 1) + (A - 1) * cos_w0 - 2 * sqrt(A) * alpha );
    a0 =           (A + 1) - (A - 1) * cos_w0 + 2 * sqrt(A) * alpha;
    a1 =      2 * ((A - 1) - (A + 1) * cos_w0                       );
    a2 =           (A + 1) - (A - 1) * cos_w0 - 2 * sqrt(A) * alpha;
  );
  b0_a0 = b0 / a0;
  b1_a0 = b1 / a0;
  b2_a0 = b2 / a0;
  a1_a0 = a1 / a0;
  a2_a0 = a2 / a0;
  filter[_.filter.biquad.struct.type] = type;
  filter[_.filter.biquad.struct.frequency] = frequency;
  filter[_.filter.biquad.struct.gain] = gain;
  filter[_.filter.biquad.struct.width.type] = width.type;
  filter[_.filter.biquad.struct.width.value] = width.value;
  filter[_.filter.biquad.struct.b0_a0] = b0_a0;
  filter[_.filter.biquad.struct.b1_a0] = b1_a0;
  filter[_.filter.biquad.struct.b2_a0] = b2_a0;
  filter[_.filter.biquad.struct.a0] = a0;
  filter[_.filter.biquad.struct.a1_a0] = a1_a0;
  filter[_.filter.biquad.struct.a2_a0] = a2_a0;
);
function _.filter.biquad.filter(filter, sample)
         local(b0_a0, b1_a0, b2_a0, a1_a0, a2_a0, x_n_2, x_n_1, x_n, y_n_2, y_n_1, y_n) (
  b0_a0 = filter[_.filter.biquad.struct.b0_a0];
  b1_a0 = filter[_.filter.biquad.struct.b1_a0];
  b2_a0 = filter[_.filter.biquad.struct.b2_a0];
  a1_a0 = filter[_.filter.biquad.struct.a1_a0];
  a2_a0 = filter[_.filter.biquad.struct.a2_a0];
  x_n_2 = filter[_.filter.biquad.struct.x_n_1];
  x_n_1 = filter[_.filter.biquad.struct.x_n];
  x_n = sample;
  y_n_2 = filter[_.filter.biquad.struct.y_n_1];
  y_n_1 = filter[_.filter.biquad.struct.y_n];
  y_n = b0_a0 * x_n + b1_a0 * x_n_1 + b2_a0 * x_n_2
                    - a1_a0 * y_n_1 - a2_a0 * y_n_2;
  filter[_.filter.biquad.struct.x_n] = x_n;
  filter[_.filter.biquad.struct.x_n_1] = x_n_1;
  filter[_.filter.biquad.struct.x_n_2] = x_n_2;
  filter[_.filter.biquad.struct.y_n] = y_n;
  filter[_.filter.biquad.struct.y_n_1] = y_n_1;
  filter[_.filter.biquad.struct.y_n_2] = y_n_2;
  y_n;
);

// Discrete Fourier Transform
// http://www.dspguide.com/CH8.PDF

function _.dft(data, reals, imaginaries) local(N, k, i, sum.real, sum.imaginary x_i, ReX, ImX) (
  ReX = reals[_.array.struct.data];
  ImX = imaginaries[_.array.struct.data];
  N = data[_.circular_buffer.struct.signal][_.array.struct.size];
  k = -1; loop(N / 2 + 1, k += 1;
    sum.real = 0;
    sum.imaginary = 0;
    i = -1; loop(N - 1 + 1, i += 1;
      x_i = _.circular_buffer.get(data, -i);
      sum.real += x_i * cos(2 * $pi * k * i / N);
      sum.imaginary += x_i * sin(2 * $pi * k * i / N);
    );
    ReX[k] = sum.real;
    ImX[k] = -sum.imaginary;
  );
);

// LINE GRAPHS

function _.graphs.line(data, x, y, width, height, thickness)
         local(data_size, data_point_width, height_half, height_midpoint, index, line.x, line.x.next, line.y, line.y.next, thickness.index) (
  data_size = data[_.circular_buffer.struct.signal][_.array.struct.size];
  data_point_width = width / data_size;
  height_half = height / 2;
  height_midpoint = y + height_half;
  line.x = x + width;
  line.y = _.circular_buffer.get(data, 0);
  index = 0; loop(data_size - 1, index += 1;
    line.x.next = line.x - data_point_width;
    line.y.next = height_midpoint - _.circular_buffer.get(data, -index) * height_half;
    thickness.index = -1; loop(thickness, thickness.index += 1;
      gfx_line(line.x, line.y + thickness.index, line.x.next, line.y.next + thickness.index, 1);
    );
    line.x = line.x.next;
    line.y = line.y.next;
  );
);

// INITIALIZATION

function _.init() (
  _.true = 1;
  _.false = 0;

  _.db.minimum = -9999;

  _.undefined = _.enumeration();
  _.error = _.enumeration();

  _.array.init();
  _.circular_buffer.init();
  _.moving_average.simple.init();
  _.filter.biquad.init();

  gfx_ext_retina = 1;
);
